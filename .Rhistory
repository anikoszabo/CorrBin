jvec = seq(from=0,to=Rglobal-kk,by=1)
lambdaest[kk+1] = sum(choose(Rglobal-jvec,kk)*q0[Rglobal-jvec+1]) / choose(Rglobal,kk)
}
# cat("The estimated lambda is",lambdaest, "\n")
# Calculation of ntprime
ntprime = expectation.vec(q0)
# Handling NaN's in the ntprime
ntprime[is.na(ntprime)] = 0
# ntprime = c(ntprime[!is.na(ntprime)],
#            rep(0,times=(length(ntprime)-sum(ntprime>0,na.rm=TRUE))))
list(q=q0,p=probability,lambda=lambdaest,ntprime=ntprime,nrs=nrs.matrix,
meanclustersize = meanclustersize)
}
# inputs: Data.Analysis & doselvlsinput
# notice the order of input doselevels
# doselvlsinput: integers
# 1st is baseline A, 2nd is response B, 3rd is response C and so on
modelestimate = function(Data.Analysis,doselvlsinput,SIMULATORNOT,RMAX) {
# extracting the dataset corresponding to particular doselvls
modeldat = DATA.Subset(Data.Analysis,doselvlsinput)
# Maximum cluster size within the extracted doselevels
# Rglobal = max(modeldat$nTotal)
# if dataset is from simulation dataset, then Rglobal=original Rglobal
# if dataset is from real observations, then Rglobal=max(modeldat$nTotal)
Rglobal = ifelse(SIMULATORNOT==TRUE,RMAX,max(modeldat$nTotal))
Dlvls = length(doselvlsinput)
# Relation between qtB.vec and qtA.vec to obtain qtB
qBqATransform <- function(thetas,qqttAA) {
qqttBB = numeric(Rglobal+1)
for(t in 0:Rglobal) {
ssuumm = 0
for(alpha in t:Rglobal) {
ssuumm = ssuumm +
(thetas^t)*((1-thetas)^(alpha-t))*choose(alpha,t)*qqttAA[alpha+1]
}
qqttBB[t+1] = ssuumm
}
qqttBB
}
# Vector representation of "prst" w.r.t "complete data" # of responses
# Calculate prst for all values of T (completedata success) for fixed clustersize=rr incompletedata success "S=ss"
# Domain of ss: {0, 1, ..., Rglobal}; {max(0,t+r-Rglobal), ..., min(t,r)}
prst.vec = function(rr,ss,qvec) {
# prst.vec is a vector
# qvec is a vector, rr/ss/tt are scalars
res = rep(0, length = Rglobal+1)
# pRst=1 if ss=tt
if (rr==Rglobal) {
res[ss+1] = 1
} else {
tt = seq(ss, Rglobal-rr+ss)
numerator = choose(tt,ss) * choose((Rglobal-tt),(rr-ss)) * qvec[tt+1]
res[tt+1] = numerator / sum(numerator)
}
res
}
# incorrect version
#prst.vec = function(rr,ss,qvec) {
#  # prst.vec is a vector
#  # qvec is a vector, rr/ss/tt are scalars
#  res = rep(0, length = Rglobal+1)
#  tt = seq(ss, Rglobal-rr+ss)
#  numerator = choose(tt,ss) * choose((Rglobal-tt),(rr-ss)) * qvec[tt+1]
#  res[tt+1] = numerator / sum(numerator)
#  res
#}
# Calculate expectation of Nt for different groups (different qt's & nrs's)
# Nt: # of clusters with exactly t successes if the "missing data" were present,
#     so that all clusters have common size Rglobal
# Vector representation of nt(prime)=E[Nt|{Sk}] w.r.t "complete data" # of responses
ntprime.est = function(qvec,nnrrss) {
p = array(0, dim=c(Rglobal,Rglobal+1,Rglobal+1))
memory.matrix = array(0, dim=c(Rglobal,Rglobal+1,Rglobal+1))
for (rr in 1:Rglobal){
for (ss in 0:rr){
p[rr,ss+1, ] = prst.vec(rr,ss,qvec)
}
}
res = numeric(Rglobal+1)
for (tt in 0:Rglobal) {
for(rr in 1:Rglobal) {
for(ss in max(0,tt+rr-Rglobal):min(tt,rr)) {
# Statement "if(nnrrss[rr,ss+1] != 0)" to prevent occurance of NAN, frequently used later on
if(nnrrss[rr,ss+1] != 0) {
memory.matrix[rr,ss+1,tt+1] = nnrrss[rr,ss+1] * p[rr,ss+1,tt+1]
}
}
}
res[tt+1] = sum(memory.matrix[,,tt+1])
}
return(res)
}
### Q function ###
# component1 represents qvec
# component2 represents ntprime
ntlog = function(component1,component2) {
ifelse(component2>0,log(component1)*component2,0)
}
# Qfunction = sum(ntlog(qtA.vec,ntprimeAk) + ntlog(qtB.transformed,ntprimeBk) +
#                   ntlog(qtC.transformed,ntprimeCk) + ntlog(qtD.transformed,ntprimeDk))
# weight / coefficient
weight = function(TT,THETA,QVEC) {
# weight returns a vector
# TT,THETA is a scalar
# QVEC is a vector
coeff = numeric(Rglobal+1)
ALPHA = seq(from=TT,to=Rglobal,by=1)
numerators =
choose(ALPHA,TT) * (THETA^TT) * ((1-THETA)^(ALPHA-TT)) * QVEC[ALPHA+1]
coeff[ALPHA+1] = ifelse(numerators>0,(numerators/sum(numerators)),0)
coeff
}
# update of theta using EM MM algorithm
thetaupdate1 = function(THETA,QVEC,NTPRIMEBK) {
weightedsum1 = 0 ; weightedsum2 = 0
weightmatrix = matrix(0,nrow=(Rglobal+1),ncol=(Rglobal+1))
for(TT in 0:Rglobal) {
weightmatrix[TT+1,] = weight(TT,THETA,QVEC)
}
for(TT in 0:Rglobal) {
alphaR = numeric(Rglobal+1)
alphat = seq(from=TT,to=Rglobal,by=1)
alphaR[alphat+1] = alphat
weightedsum1 = weightedsum1 + NTPRIMEBK[TT+1]*TT
weightedsum2 = weightedsum2 + NTPRIMEBK[TT+1]*sum(weightmatrix[TT+1,]*alphaR)
}
weightedsum1/weightedsum2
}
# update of theta using EM MM algorithm
thetaupdate2 = function(THETA,QVEC,NTPRIMEBK) {
weightedsum1 = 0 ; weightedsum2 = 0
for(TT in 0:Rglobal) {
alphaR = numeric(Rglobal+1)
alphat = seq(from=TT,to=Rglobal,by=1)
alphaR[alphat+1] = alphat
weightedsum1 = weightedsum1 + NTPRIMEBK[TT+1]*TT
weightedsum2 = weightedsum2 + NTPRIMEBK[TT+1]*sum(weight(TT,THETA,QVEC)*alphaR)
}
weightedsum1/weightedsum2
}
# assuming uniform effectiveness within two specifc doselevels
# initial value of lambda for the baseline
# baseline, higher values in this situation
#          resultpooled = qestimate(Data.Analysis,doselvlsinput,Rglobal)
#          lambdaApooled = resultpooled$lambda
# reason that qtA also pooled over all doselevels: lambdaA never used in EM algorithm
#          qtApooled = resultpooled$q          # baseline
# notice the order of input doselevels
resultA = qestimate(Data.Analysis,doselvlsinput[1],Rglobal)  # baseline A
meanclustersizeA = resultA$meanclustersize
lambdaAnotpooled = resultA$lambda  # baseline A, nonparametric estimate for comparison
# Initial values for qt's from group A & B
qtA.notpooled = resultA$q          # baseline A, nonparametric estimate for comparison
qtA.vec = qtA.notpooled            # baseline qtA.notpooled  # qtApooled before
nrsA = resultA$nrs                 # baseline A
# Calculate ntprime's for group A based on non-parametric model
ntprimeAk = ntprime.est(qtA.notpooled,nrsA)
# which is essentially the original values of ntprimeA = resultA$ntprime
# Parameter storage
MeanCluSizeS = numeric(Dlvls)
LambdaModelS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
LambdaNonParS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
QAModelInitS = numeric(Rglobal+1)
QAModelTraceS = numeric(Rglobal+1)
QNonParS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
QModelS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
NrsS = matrix(0,nrow=(Dlvls*Rglobal),ncol=(Rglobal+1))
ThetaInitS = numeric(Dlvls-1)
ThetaTraceS = numeric(Dlvls-1)
NtprimeInitS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
NtprimeTraceS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
NtprimeModelS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
NtprimeNonParS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
MeanCluSizeS[1] = meanclustersizeA
LambdaNonParS[1,] = lambdaAnotpooled
QNonParS[1,] = qtA.notpooled
QAModelInitS = qtA.notpooled
NrsS[1:Rglobal,] = nrsA
NtprimeNonParS[1,] = ntprimeAk
NtprimeInitS[1,] = ntprimeAk
for (dlvl in 2:Dlvls) {
resultB = qestimate(Data.Analysis,doselvlsinput[dlvl],Rglobal)  # response
meanclustersizeB = resultB$meanclustersize
lambdaB = resultB$lambda           # nonparametric estimate for comparison
qtB.vec = resultB$q
nrsB = resultB$nrs
# Initial value for theta's
theta1 = lambdaB[2] / lambdaAnotpooled[2]
# response initial value according to seme-parametric model
qtB.transformed = qBqATransform(theta1,QAModelInitS)
ntprimeBk = ntprime.est(qtB.transformed,nrsB)
# different from ntprimeB = resultB$ntprime since qtB.transformed is used
# Parameter storasge fir each dose level
MeanCluSizeS[dlvl] = meanclustersizeB
LambdaNonParS[dlvl,] = lambdaB
QNonParS[dlvl,] = qtB.vec
NrsS[((1:Rglobal)+(dlvl-1)*Rglobal),] = nrsB
ThetaInitS[dlvl-1] = theta1
NtprimeNonParS[dlvl,] = ntprime.est(qtB.vec,nrsB)
NtprimeInitS[dlvl,] = ntprimeBk
}
# update of qtA's using EM MM algorithm
qtAupdate = function(THETAS,QVEC,NTPRIMEModels) {
DlvlMinus1 = length(THETAS)
ProductSum = matrix(0,nrow=DlvlMinus1,ncol=Rglobal+1)
NUMERATOR = numeric(Rglobal+1)
for(BETA in 0:Rglobal) {
weightBETAS = matrix(0,nrow=DlvlMinus1,ncol=(BETA+1))
for(RHO in 0:BETA) {
for(dlvlMinus in 1:DlvlMinus1) {
weightBETAS[dlvlMinus,RHO+1] = weight(RHO,THETAS[dlvlMinus],QVEC)[BETA+1]
}
}
for(dlvls in 1:DlvlMinus1) {
ProductSum[dlvls,BETA+1] = sum(weightBETAS[dlvls,] * (NTPRIMEModels[(dlvls+1),1:(BETA+1)]))
}
NUMERATOR[BETA+1] = NTPRIMEModels[1,BETA+1] + sum(ProductSum[,BETA+1])
}
NUMERATOR / sum(NUMERATOR)
}
## Iterations of EM algorithm until convergence ##
# Absolute convergence: difference1 & difference1 <= 1e-7
itermax = 5000; iter = 0
difference = 10
while((difference > (1e-7)) & (iter < itermax)) {
iter = iter + 1
# Initial value for qtA and theta's
ThetaTraceS = ThetaInitS
QAModelTraceS = QAModelInitS
###########################################################
##################### EM MM ALGORITHM #####################
######## Expectation Maximization Minorize-Maximize #######
###########################################################
######################
## EXPECTATION STEP ##
######################
# values and parameters (initial values) required in E Step
# nrs for group A & B & C & D
# qtA for group A
# functions needed in the E step
# qBqATransform: obtain qtB, qtC according to SEMIPARAMETRIC using qtA & theta's
# prst.vec: obtain prst, which will be used in expectation
# ntprime.est: expectation
# Qfunction: expectation of log-likelihood
QsModelEst = matrix(0,nrow=(Dlvls-1),ncol=(Rglobal+1))
for(dlvlMinus in 1:(Dlvls-1)) {
QsModelEst[dlvlMinus,] = qBqATransform(ThetaTraceS[dlvlMinus],QAModelTraceS)
}
# expectation
NtprimeTraceS = matrix(0,nrow=Dlvls,ncol=(Rglobal+1))
NtprimeTraceS[1,] = ntprime.est(QAModelTraceS,nrsA)
for(dlvlMinus in 1:(Dlvls-1)) {
NtprimeTraceS[dlvlMinus+1,] = ntprime.est(QsModelEst[dlvlMinus,],NrsS[((1:Rglobal)+dlvlMinus*Rglobal),])
}
##############################
##### MAXIMIZATION STEP ######
# Minorize-Maximize inserted #
##############################
# theta,qtA.vec: from the pre kth iteration
# ntprimeBk: expectaion from the pre kth iteration
# maximization (MM inserted)
# theta1&2pre,qtAspre: from previous kth iteration
# ntprimeAkpre,ntprimeBkpre,ntprimeCkpre: expectaion from previous kth iteration
for(dlvlMinus in 1:(Dlvls-1)) {
ThetaInitS[dlvlMinus] = thetaupdate1(ThetaTraceS[dlvlMinus],QAModelTraceS,NtprimeTraceS[dlvlMinus+1,])
}
QAModelInitS = qtAupdate(ThetaTraceS,QAModelTraceS,NtprimeTraceS)
difference = sum(abs(QAModelInitS-QAModelTraceS)) + sum(abs(ThetaInitS-ThetaTraceS))
}
plot(QAModelInitS,main="EM MM Algorithm Estimate of qtAs (Baseline)",xlab="r",ylim=c(0,1))
# using optimized value of qtA to obtain corresponding lambda's for baseline (group A)
lambdabaseline = numeric(Rglobal+1)
for(tt in 0:Rglobal) {
sumttjj = 0
for(jj in 0:(Rglobal-tt)) {
sumttjj = sumttjj + choose((Rglobal-tt),jj)*QAModelInitS[Rglobal-jj+1]/choose(Rglobal,(Rglobal-jj))
}
lambdabaseline[tt+1] = sumttjj
}
#cat("lambdaA from model is",lambdabaseline,sep=" ","\n")
plot(lambdabaseline,main="Lambda Comparison Semi-parametric vs Non-parametric",ylim=c(0,1),type="b")
points(LambdaNonParS[1,],col="orange",type="b")
LambdaModelS[1,] = lambdabaseline
# using qtA and theta from EM optimization results to obtain lambda's for response
exponents = seq(from=0,to=Rglobal,by=1)
for(tt in 0:Rglobal) {
for(LVLs in 2:Dlvls) {
LambdaModelS[LVLs,tt+1] = ((ThetaInitS[LVLs-1])^(exponents[tt+1])) * lambdabaseline[tt+1]
}
}
QModelS[1,] = QAModelInitS
for(LVLs in 2:Dlvls) {
QModelS[LVLs,] = qBqATransform(ThetaInitS[LVLs-1],QAModelInitS)
}
list(Rglobal=Rglobal,
MeanCluSizeS = MeanCluSizeS,
NrsS = NrsS,
QNonParS = QNonParS,
QModelS = QModelS,
ThetaEst = ThetaInitS,
LambdaNonParS = LambdaNonParS,
LambdaModelS = LambdaModelS,
QBaseline = QAModelInitS)
}
# THETA123: interger indicating dose level category
# LAMBDAalpha: interger indicating order in baseline lambda estimates
VARIANCE = function(ESTIMATES) {
Rglobal = ESTIMATES$Rglobal
thetasmodel = ESTIMATES$ThetaEst
lambdaAmodel = ESTIMATES$LambdaModelS[1,]
nrs = ESTIMATES$NrsS
nrsA = ESTIMATES$NrsS[1:Rglobal,]
p1 = function(ALPHA,RR,SS,THETA123) {
P11 = numeric(RR-SS+1)
P12 = numeric(RR-SS+1)
P13 = numeric(RR-SS+1)
P14 = numeric(RR-SS+1)
P15 = numeric(RR-SS+1)
for(j in 0:(RR-SS)) {
P11[j+1] = ((-1)^j) * choose(RR-SS,j) * (lambdaAmodel[SS+j+1]) * ((thetasmodel[THETA123])^(SS+j))
P12[j+1] = ((-1)^j) *(SS+j)*(SS+j-1)*choose(RR-SS,j)*(lambdaAmodel[SS+j+1])*((thetasmodel[THETA123])^(SS+j-2))
P13[j+1] = ((-1)^j) *(SS+j)*choose(RR-SS,j)*(lambdaAmodel[SS+j+1])*((thetasmodel[THETA123])^(SS+j-1))
P14[j+1] = ((-1)^j) *(ALPHA-SS-j)* choose(RR-SS,j) * (lambdaAmodel[SS+j+1]) * ((thetasmodel[THETA123])^j)
P15[j+1] = ((-1)^j) * choose(RR-SS,j) * (lambdaAmodel[SS+j+1])
}
P11sum = sum(P11)
P12sum = sum(P12)
P13sum = sum(P13)
P14sum = sum(P14)
P15sum = sum(P15)
list(P11sum=P11sum, P12sum=P12sum, P13sum=P13sum,P14sum=P14sum,P15sum=P15sum)
}
p2 = function(THETA123) {
NRS = nrs[(1:Rglobal)+(THETA123*Rglobal), ]
NRS
}
# returns a scalar
Dthetatheta = function(THETA123) {
part2 = p2(THETA123)
THETAgSquare = matrix(0,nrow=Rglobal,ncol=Rglobal+1)
for(rr in 1:Rglobal) {
for(ss in 0:rr) {
part1 = p1(2,rr,ss,THETA123)
part11 = part1$P11sum
part12 = part1$P12sum
part13 = part1$P13sum
THETAgSquare[rr,ss+1] = part2[rr,ss+1] * (part12*part11-(part13^2)) / (part11^2)
}
}
THETAgSquaresum = sum(THETAgSquare)
THETAgSquaresum
}
# resturns a scalar
Dthetalambda = function(THETA123,LAMBDAalpha) {
part2 = p2(THETA123)
ThetaLambda = matrix(0,nrow=Rglobal,ncol=Rglobal+1)
for(rr in LAMBDAalpha:Rglobal) {
for(ss in 0:min(LAMBDAalpha,rr)) {
part1 = p1(LAMBDAalpha,rr,ss,THETA123)
part11 = part1$P11sum
part14 = part1$P14sum
ThetaLambda[rr,ss+1] = part2[rr,ss+1] * part14 * ((-1)^(LAMBDAalpha-ss)) *
choose(rr-ss,LAMBDAalpha-ss) * ((thetasmodel[THETA123])^(LAMBDAalpha+ss-1)) / (part11^2)
}
}
ThetaLambdasum = sum(ThetaLambda)
ThetaLambdasum
}
p3 = function(THETA123,ALPHA,RR,SS,NRSG) {
P31 = NRSG[RR,SS+1] * ((-1)^(2*(ALPHA-SS)+1)) * (choose(RR-SS,ALPHA-SS)^2)
P32 = NRSG[RR,SS+1] * ((-1)^(2*(ALPHA-SS)+1)) * (choose(RR-SS,ALPHA-SS)^2) * ((thetasmodel[THETA123])^(2*ALPHA))
list(P31=P31,P32=P32)
}
Dlambda1lambda1 = function(LAMBDAalpha) {
LambdaSquare1 = matrix(0,nrow=Rglobal,ncol=Rglobal+1)
LambdaSquare2 = array(0,dim=c(Rglobal,Rglobal+1,3))
for(rr in LAMBDAalpha:Rglobal) {
for(ss in 0:min(rr,LAMBDAalpha)) {
for(gg in 1:length(thetasmodel)) {
part1 = p1(LAMBDAalpha,rr,ss,gg)
part11 = part1$P11sum
part15 = part1$P15sum
part2 = p2(gg)
part3 = p3(gg, LAMBDAalpha, rr, ss, part2)
part32 = part3$P32
LambdaSquare2[rr,ss+1,gg] = part32 / (part11^2)
}
part30 = p3(1, LAMBDAalpha, rr, ss, nrsA)$P31
LambdaSquare1[rr,ss+1] = part30 / (part15^2)
}
}
LambdaSquaresum = sum(LambdaSquare1) + sum(LambdaSquare2)
LambdaSquaresum
}
p4 = function(THETA123,ALPHA,BETA,RR,SS,NRSG) {
P41 = NRSG[RR,SS+1] * ((-1)^(ALPHA+BETA-2*SS+1)) *choose(RR-SS,ALPHA-SS)*choose(RR-SS,BETA-SS)
P42 = NRSG[RR,SS+1] * ((-1)^(ALPHA+BETA-2*SS+1)) *choose(RR-SS,ALPHA-SS)*choose(RR-SS,BETA-SS) * ((thetasmodel[THETA123])^(ALPHA+BETA))
list(P41=P41,P42=P42)
}
Dlambda1lambda2 = function(LAMBDAalpha,LAMBDAbeta) {
LambdaSquare3 = matrix(0,nrow=Rglobal,ncol=Rglobal+1)
LambdaSquare4 = array(0,dim=c(Rglobal,Rglobal+1,length(thetasmodel)))
for(rr in max(LAMBDAalpha,LAMBDAbeta):Rglobal) {
for(ss in 0:min(rr,LAMBDAalpha,LAMBDAbeta)) {
for(gg in 1:length(thetasmodel)) {
part1 = p1(LAMBDAalpha,rr,ss,gg)
part11 = part1$P11sum
part15 = part1$P15sum
part2 = p2(gg)
part4 = p4(gg, LAMBDAalpha, LAMBDAbeta, rr, ss, part2)
part42 = part4$P42
LambdaSquare4[rr,ss+1,gg] = part42 / (part11^2)
}
part40 = p4(1, LAMBDAalpha, LAMBDAbeta, rr, ss, nrsA)$P41
LambdaSquare3[rr,ss+1] = part40 / (part15^2)
}
}
Lambda1lambda2sum = sum(LambdaSquare3) + sum(LambdaSquare4)
Lambda1lambda2sum
}
covariance = matrix(0,nrow=(length(thetasmodel)+Rglobal),ncol=(length(thetasmodel)+Rglobal))
for (i in 1:length(thetasmodel)) {
covariance[i,i] = Dthetatheta(i)
}
for (i in 1:length(thetasmodel)) {
for (j in 1:Rglobal) {
entry = Dthetalambda(i,j)
covariance[i,j+length(thetasmodel)] = entry
covariance[j+length(thetasmodel),i] = entry
}
}
for (j in 1:Rglobal) {
covariance[j+length(thetasmodel),j+length(thetasmodel)] = Dlambda1lambda1(j)
}
for (j in 1:Rglobal) {
for (k in 1:Rglobal) {
covariance[j+length(thetasmodel),k+length(thetasmodel)] = Dlambda1lambda2(j,k)
}
}
covariance
}
# for exmaple, the simulated dataset
dataprocessed = DATA.Reversion(GENERATE)
doselevels = DoseLevels(GENERATE)
cat("The doselevels in this dataset are",doselevels,sep=" ","\n")
# first loc is baseline A; second loc is response B; third loc is response C
Doselvlsinput = doselevels[c(1,2,3,4)]
cat("The input doselevels to the model are",Doselvlsinput,sep=" ","\n")
fit = modelestimate(dataprocessed,c(0,1,2,3),FALSE,1)
cat("The model estimate results are:",sep=" ","\n")
print(fit)
cov = VARIANCE(fit)
SecndObserved = as.data.frame(cov,row.names=c("theta1","theta2","theta3","lambda1","lambda2","lambda3",
"lambda4","lambda5","lambda6","lambda7","lambda8","lambda9",
"lambda10"))
colnames(SecndObserved) = c("theta1","theta2","theta3","lambda1","lambda2","lambda3","lambda4","lambda5",
"lambda6","lambda7","lambda8","lambda9","lambda10")
#BoricAcidMousedata_processed <- read_csv("C:/Users/xinqi/Desktop/BoricAcidMousedata_processed.csv")
#BoricAcidRatdata_processed <- read_csv("C:/Users/xinqi/Desktop/BoricAcidRatdata_processed.csv")
#BoricAcidRatdata_processed <- read_csv("z:/EOGeorge/Data/Binary/BoricAcidRatdata_processed.csv")
BoricAcidMousedata_processed <- read_csv("z:/EOGeorge/Data/Binary/BoricAcidMousedata_processed.csv")
dataprocessed = DATA.Reversion(BoricAcidMousedata_processed)
DoseLevels(dataprocessed)
fit = modelestimate(dataprocessed,c(0.4,0,0.1,0.2),FALSE,1)
fit
cov = VARIANCE(fit)
cov
table(dataprocessed$nTotal)
table(data$nResp, dataprocessed$nTotal)
table(dataprocessed$nResp, dataprocessed$nTotal)
table(dataprocessed$nResp, dataprocessed$nTotal, dataprocessed$dose)
debug(VARIANCE)
cov = VARIANCE(fit)
View(nrs)
View(covariance)
debug(Dlambda1lambda1)
undebug(Dlambda1lambda1)
debug(Dlambda1lambda1)
p1
p2
p3
part2[rr,ss+1]
thetasmodel[gg]
thetasmodel[gg]^(2*LAMBDAalpha)
LAMBDAalpha
0.28^12
0.28^24
part32 / (part11^2)
LambdaSquare2[rr,ss+1,]
LambdaSquare1[rr,ss+1]
part30
nrsA[rr,s]
nrsA[rr,ss]
LambdaSquare1
LambdaSquare2[,,1]
LambdaSquare2[,,2]
lambdaAmodel
MaxClusterSize = 20
qbaseline = dbetabinom(0:MaxClusterSize,size=MaxClusterSize, m=0.5, s=1)
thetaPopulat = c(0.75,0.5,0.25)
GENERATE = DataGenerat(qbaseline,thetaPopulat,MaxClusterSize)
# for exmaple, the simulated dataset
dataprocessed = DATA.Reversion(GENERATE)
doselevels = DoseLevels(GENERATE)
# first loc is baseline A; second loc is response B; third loc is response C
Doselvlsinput = doselevels[c(1,2,3,4)]
fit = modelestimate(dataprocessed,c(0,1,2,3),FALSE,1)
VARIANCE(fit)
undebug(VARIANCE)
cov = VARIANCE(fit)
-solve(cov)
setwd("Z:/RForge/corrbin/pkg/CorrBin")
